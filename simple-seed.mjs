/**
 * Simple database seeding script with minimal columns
 * Usage: node simple-seed.mjs [count]
 */

import { createClient } from '@supabase/supabase-js';
import dotenv from 'dotenv';

// Load environment variables
dotenv.config();

// Get command line argument for count
const count = parseInt(process.argv[2] || '10', 10);

// Check if required environment variables are set
const supabaseUrl = process.env.SUPABASE_URL;
const supabaseKey = process.env.SUPABASE_SERVICE_ROLE_KEY;

if (!supabaseUrl || !supabaseKey) {
  console.error('Error: SUPABASE_URL and SUPABASE_SERVICE_ROLE_KEY must be set in .env file');
  process.exit(1);
}

// Create Supabase client
const supabase = createClient(supabaseUrl, supabaseKey);

// Pattern types and other data
const patternTypes = [
  'Bull Flag', 
  'Bear Flag', 
  'Cup and Handle', 
  'Double Bottom', 
  'Double Top',
  'Ascending Triangle',
  'Descending Triangle',
  'Symmetrical Triangle'
];

const symbols = ['AAPL', 'MSFT', 'GOOGL', 'AMZN', 'META', 'TSLA', 'NVDA', 'AMD'];
const timeframes = ['1h', '4h', '1d', '1w'];

// Helper functions
function randomItem(array) {
  return array[Math.floor(Math.random() * array.length)];
}

function randomDecimal(min, max, decimals = 2) {
  const rand = Math.random() * (max - min) + min;
  const power = Math.pow(10, decimals);
  return Math.round(rand * power) / power;
}

function randomBetween(min, max) {
  return Math.floor(Math.random() * (max - min + 1) + min);
}

// Generate pattern data for detected_patterns
function generatePattern() {
  const symbol = randomItem(symbols);
  const timeframe = randomItem(timeframes);
  const patternType = randomItem(patternTypes);
  
  const basePrice = randomDecimal(50, 500, 2);
  const isBullish = patternType.includes('Bull') || 
                    patternType.includes('Cup') || 
                    patternType.includes('Bottom') ||
                    patternType.includes('Ascending');
  
  const priceChangePercent = randomDecimal(2, 15) / 100;
  const targetPrice = isBullish 
    ? basePrice * (1 + priceChangePercent) 
    : basePrice * (1 - priceChangePercent);
  
  const stopLoss = isBullish
    ? basePrice * (1 - randomDecimal(1, 5) / 100)
    : basePrice * (1 + randomDecimal(1, 5) / 100);
    
  const riskRewardRatio = Math.abs((targetPrice - basePrice) / (stopLoss - basePrice));
  const confidenceScore = randomBetween(60, 95);
  const multiTimeframeConfirmation = Math.random() > 0.5;
  const patternData = {
    priceHistory: Array.from({ length: 30 }, () => randomDecimal(basePrice * 0.9, basePrice * 1.1)),
    trendlinePoints: [
      { x: 0, y: basePrice * 0.95 },
      { x: 15, y: basePrice * 0.98 },
      { x: 30, y: basePrice * 1.01 }
    ]
  };
  
  return {
    symbol,
    pattern_type: patternType,
    timeframe,
    confidence_score: confidenceScore,
    multi_timeframe_confirmation: multiTimeframeConfirmation,
    entry_price: basePrice,
    target_price: targetPrice,
    stop_loss: stopLoss,
    risk_reward_ratio: riskRewardRatio,
    detected_at: new Date().toISOString(),
    pattern_data: patternData
  };
}

// Generate backtest results with minimal fields
function generateBacktestResult(patternId) {
  const success = Math.random() > 0.3; // 70% success rate
  const profitLossPercent = success 
    ? randomDecimal(1, 15) 
    : -randomDecimal(1, 10);
  
  const daysToBreakout = randomBetween(1, 14);
  const daysToTarget = success ? daysToBreakout + randomBetween(1, 10) : null;
  const maxDrawdown = success ? -randomDecimal(0.5, 5) : -randomDecimal(5, 15);
  
  return {
    pattern_id: patternId,
    success,
    profit_loss_percent: profitLossPercent,
    days_to_breakout: daysToBreakout,
    days_to_target: daysToTarget,
    max_drawdown: maxDrawdown
  };
}

async function getTableColumns(tableName) {
  // Query to get column information for the table
  const { data, error } = await supabase.rpc('get_table_info', { table_name: tableName });
  
  if (error) {
    console.error(`Error getting columns for ${tableName}:`, error);
    return null;
  }
  
  return data;
}

async function seedDetectedPatterns() {
  console.log(`Seeding database with ${count} patterns...`);
  
  // Generate patterns
  const patterns = Array.from({ length: count }, () => generatePattern());
  
  // Insert patterns into database
  const { data: insertedPatterns, error: patternsError } = await supabase
    .from('detected_patterns')
    .insert(patterns)
    .select();
  
  if (patternsError) {
    console.error('Error inserting patterns:', patternsError);
    console.log('Trying to create detected_patterns table...');
    
    // Try to create the table
    const createTableSql = `
    CREATE TABLE IF NOT EXISTS detected_patterns (
      id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
      symbol TEXT NOT NULL,
      pattern_type TEXT NOT NULL,
      timeframe TEXT NOT NULL,
      confidence_score INTEGER NOT NULL,
      multi_timeframe_confirmation BOOLEAN NOT NULL DEFAULT FALSE,
      entry_price DECIMAL(12,4) NOT NULL,
      target_price DECIMAL(12,4) NOT NULL,
      stop_loss DECIMAL(12,4) NOT NULL,
      risk_reward_ratio DECIMAL(8,2) NOT NULL,
      detected_at TIMESTAMP WITH TIME ZONE NOT NULL,
      pattern_data JSONB NOT NULL,
      created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
    );
    `;
    
    try {
      await fetch(`${supabaseUrl}/rest/v1/sql`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Authorization': `Bearer ${supabaseKey}`,
          'apikey': supabaseKey
        },
        body: JSON.stringify({ query: createTableSql })
      });
      
      // Try inserting again
      const { data, error } = await supabase
        .from('detected_patterns')
        .insert(patterns)
        .select();
        
      if (error) {
        console.error('Error inserting patterns after table creation:', error);
        process.exit(1);
      }
      
      return data;
    } catch (err) {
      console.error('Error creating table:', err);
      process.exit(1);
    }
  }
  
  console.log(`Successfully inserted ${insertedPatterns.length} patterns`);
  
  return insertedPatterns;
}

async function seedBacktestResults(patterns) {
  console.log('Generating backtest results...');
  
  // Generate basic backtest results
  const backtestResults = patterns.map(pattern => generateBacktestResult(pattern.id));
  
  // First, try inserting with minimal fields
  const { error: minimalError } = await supabase
    .from('backtest_results')
    .insert(backtestResults);
  
  if (!minimalError) {
    console.log(`Successfully inserted ${backtestResults.length} backtest results`);
    return true;
  }
  
  console.error('Error with minimal backtest results:', minimalError);
  console.log('Trying to create or update backtest_results table...');
  
  // Try to create/update backtest_results table
  const createBacktestTableSql = `
  CREATE TABLE IF NOT EXISTS backtest_results (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    pattern_id BIGINT NOT NULL,
    success BOOLEAN NOT NULL,
    profit_loss_percent DECIMAL(8,2) NOT NULL,
    days_to_breakout INTEGER,
    days_to_target INTEGER,
    max_drawdown DECIMAL(8,2),
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
  );
  `;
  
  try {
    const response = await fetch(`${supabaseUrl}/rest/v1/sql`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'Authorization': `Bearer ${supabaseKey}`,
        'apikey': supabaseKey
      },
      body: JSON.stringify({ query: createBacktestTableSql })
    });
    
    if (!response.ok) {
      console.error('Error creating backtest_results table:', await response.text());
    } else {
      console.log('Backtest_results table created/updated successfully');
      
      // Try inserting again
      const { data, error } = await supabase
        .from('backtest_results')
        .insert(backtestResults)
        .select();
        
      if (error) {
        console.error('Error inserting backtest results after table update:', error);
        return false;
      }
      
      console.log(`Successfully inserted ${data.length} backtest results`);
      return true;
    }
  } catch (err) {
    console.error('Error updating table:', err);
    return false;
  }
  
  return false;
}

async function seedDatabase() {
  try {
    // Seed detected patterns
    const patterns = await seedDetectedPatterns();
    
    // Seed backtest results
    await seedBacktestResults(patterns);
    
    console.log('Database seeding completed successfully!');
  } catch (err) {
    console.error('Unexpected error:', err);
    process.exit(1);
  }
}

seedDatabase(); 